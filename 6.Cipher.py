def get_number1():
    import random
    n = random.choice(range(3, 21))  # Генерация первого числа.
    # Вывод цифрового замка с заполненным первым полем.
    print('__________________________________________________\n|    |                                           |')
    if n < 10:  # Если число из одной цифры, добавляется пробел перед числом.
        print('| ', n, '|                                           |')
    else:
        print('|', n, '|                                           |')
    print('|____|___________________________________________|')
    return n


def get_number2(n):
    # math.ceil округляет арифметически, а не до чётного, как round,
    # и не только в меньшую сторону, как int.
    # import math
    result = ''
    # Перебор всех пар чисел.
    # Первое в паре число перебирается в отрезке от 1 до арифметически округлённой половины заданного числа n (number1),
    # т.к. потом пары будут повторяться в обратном порядке. (Использована подсказка в задаче.)
    # for i in range(1, math.ceil(n / 2)):
    # Но можно не импортировать модуль math, а воспользоваться следующим алгоритмом:
    if n % 2 == 0:
        z = n // 2
    else:
        z = n // 2 + 1
    for i in range(1, z):
        # Перебор второго в паре числа. Т.к. по условию заданное число не меньше 3,
        # и не рассматриваются повторяющиеся пары, то перебор начинается с числа 3 - 1 = 2.
        for j in range(i + 1, n):
            # Если заданное число безостатка делится на сумму пары чисел и числа в паре не повторяются,
            if n % (i + j) == 0 and i != j:
                result += str(i) + str(j)  # записывается найденная пара в результирующую строку (с преобразованием).
    return result


# def test_get_number2():
#     answers = {
#         3: 12,
#         4: 13,
#         5: 1423,
#         6: 121524,
#         7: 162534,
#         8: 13172635,
#         9: 1218273645,
#         10: 141923283746,
#         11: 11029384756,
#         12: 12131511124210394857,
#         13: 112211310495867,
#         14: 1611325212343114105968,
#         15: 1214114232133124115106978,
#         16: 1317115262143531341251161079,
#         17: 11621531441351261171089,
#         18: 12151811724272163631545414513612711810,
#         19: 118217316415514613712811910,
#         20: 13141911923282183731746416515614713812911
#     }
#     for i, j in answers.items():
#         num = get_number2(i)
#         print(f'{i}: {num}  {j}    {num == str(j)}')


number1 = get_number1()  # Для ленивой фантазии.
number = input('Введите число, указанное в первом поле цифрового замка: ')
if number.isdigit():  # Если введены только цифры, преобразовать их в число.
    number = int(number)
while number != number1:  # Для невнимательных.
    number = input('Проверьте число, указанное в первом поле цифрового замка, и введите его: ')
    if number.isdigit():
        number = int(number)
# Ели не использовать функцию get_number1, а получать первое число от пользователя, то используем блок
# while 3 > number > 20:
#    number = int(input('Введённое число некорректно, введите число из отрезка от 3 до 20: '))
print('Ваше второе число-ключ:', get_number2(number1))
# test_get_number2()  # тест основного алгоритма
